<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么是Servlet</title>
    <link href="/%E4%BB%80%E4%B9%88%E6%98%AFservlet/"/>
    <url>/%E4%BB%80%E4%B9%88%E6%98%AFservlet/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet:"></a>什么是Servlet:</h2><p><strong>阅读之前,你应该至少会servlet的基本使用.只是不太清楚原理而已</strong>**</p><p>网上的回答大都是:一种小服务程序或者服务连接器.也有的说是一种规范.这对于当时学servlet的我来说,可谓是让我十分困惑.很抽象,抽象的地方在于,servlet只是一个接口,但是我们只要自定义一个实现了这个接口的类,重写里面的service方法,就能完成一个简单的web小案例,就能在前端页面显示出数据了.但是为什么我们写的类只要实现了那个servlet接口,就会有这些功能呢?后来知道是因为Tomcat,但是Tomcat是什么,有的说它是一个web服务器,也有的说Tomcat是一个servlet容器.这下我就更抽象了,对于我这种只知道java类的人来说,无疑是用一个更抽象的名词去解释另一个名词.所以,今天就用自己的理解来谈谈servlet和tomcat,这个所谓的接口规范和serlet容器是什么!</p><p>点开servlet源码,里面只有几个方法的定义.我们都知道,如果要编写一个自己的servlet类,最简单的就是实现该接口的service方法.然后在xml中配置路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Servlet</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException;<br>    <br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span>;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello Servlet&quot;</span>);<br> &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.demo1.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>然后我们在浏览器访问<a href="http://ip:port/hello,控制台就会打印出&quot;Hello">http://ip:port/hello,控制台就会打印出&quot;Hello</a> Servlet”这句话.那么在整个过程中,tomcat扮演了什么样的角色呢?它就是接收浏览器发送过来的请求,然后把这个请求转交给你自己编写的servlet类,由你自己编写的servler类来处理这个请求.所以Tomcat最基本的功能之一就是,接收浏览器发送过来的信息,把这个接收到的信息给到你写的servlet类里面给你处理,你处理好后,在通过tomcat把需要返回的数据或者资源传输给前端.当然上面的例子中我们并没有需要返回给浏览器任何数据或者资源,只是接受到客户端访问/hello请求后,我们在控制台打印一条简单的语句而已.</p><p>所以,广义的serlet就是你自己写的一个实现了servlet接口的类.我们在idea中编写的servlet,可以点击一下就启动成功.在这个过程中可能没有感受到tomcat的作用,实际上在你运行你的web项目时,在tomcat安装目录下的webapps目录中,已经存放着编译好的web项目了.所以servlet是依托于tomcat的.这也就是为什么springboot项目说不需要独立安装tomcat,你可能会想,springboot和tomcat有什么关系?现在应该就能体会了.</p><p>那么servletRequest是从哪里来的呢?就是Tomcat把客户端传递过来的<strong>所有数据封装</strong>成这个request对象后,给需要使用的servlet调用.这也就是为什么我们可以从request里面直接得到请求头,cookie等信息的原因.同样servletResonpse对象也是由Tomcat生成的.只需要把需要返回的数据填充在response中,tomcat会自己把这个response对象返回.</p><h1 id="tomcat内幕"><a href="#tomcat内幕" class="headerlink" title="tomcat内幕"></a>tomcat内幕</h1><blockquote><p>下面文章的绝大部门内容来源于&lt;深入剖析Tomcat&gt; (美) Budi Kurniawan著,曹旭东 译</p><p>这本书是依据Tomcat4和5来讲解.但是其包含了Tomcat的最原始的味道,虽然现在Tomcat已经更新到了9,但是依旧不影响它的经典.</p><p>如果文章不是特别理解,希望可以阅读孙卫琴老师的&lt;javaweb开发技术详解&gt;作为前置知识,一本很适合学习javaweb的书籍</p><p>希望你了解socket编程原理,http协议,servlet的使用.</p></blockquote><p>文章的源码来自:<a href="https://brainysoftware.com/book/9780975212806;jsessionid=8433E06AEB73BE1C249D4DB332821D9E">How Tomcat Works (brainysoftware.com)</a>.源代码省略了包名等很多信息.需要的可以看书或者去上面的官网下载.</p><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>现在已经使用到了HTTP1.1版本了.这里是它的中文文档:<a href="https://www.cnblogs.com/Kimbing-Ng/p/12411017.html">HTTP1.1协议-RFC2616-中文版 - KimBing_Ng - 博客园 (cnblogs.com)</a></p><p>假设你已经知道了Http协议的内容和socket编程.</p><p>应用程序的入口点（静态main()方法〉在HttpServer类中。main()方法创建一个HttpServer实例，然后，调用其await()方法。顾名思义，await()方法会在指定端口上等待HTTP请求，对其进行处理，然后发送响应信息回客户端。在接收到关闭命令前，它会保持等待状态。该应用程序仅发送位于指定目录的静态资源的请求，如HTML文件和图像文件。它也可以将传入到的HTTP请求字节流显示到控制台上。但是，它并不发送任何头信息到浏览器，如日期或cookies 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServer</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WEB_ROOT</span> <span class="hljs-operator">=</span><br>    System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + File.separator  + <span class="hljs-string">&quot;webroot&quot;</span>;<br><br>  <span class="hljs-comment">// shutdown command</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SHUTDOWN_COMMAND</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/SHUTDOWN&quot;</span>;<br><br>  <span class="hljs-comment">// the shutdown command received</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">shutdown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">HttpServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServer</span>();<br>    server.await();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      serverSocket =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port, <span class="hljs-number">1</span>, InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>      System.exit(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Loop waiting for a request</span><br>    <span class="hljs-keyword">while</span> (!shutdown) &#123;<br>      <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">OutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        socket = serverSocket.accept();<br>        input = socket.getInputStream();<br>        output = socket.getOutputStream();<br><br>       <span class="hljs-comment">//从socket中得到输入流对象,封装成request.</span><br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(input);<br>          <span class="hljs-comment">//这里的parse方法就是解析从socket输入流得到的http的原始数据,封装成一个一个的对象,然后就可以通过           //request.getXXX()来获得协议中的内容了.所以我们在servlet中调用的各种request.getXXX()方法,就是这样被解析然后封装的   </span><br>        request.parse();<br><br>        <span class="hljs-comment">// 创建响应的对象</span><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(output);<br>        response.setRequest(request);<br>        response.sendStaticResource();<br><br>        <span class="hljs-comment">// 关闭这个套接字</span><br>        socket.close();<br><br>        <span class="hljs-comment">//这里的意思是前端通过传一个url来控制这个程序是否关闭</span><br>        shutdown = request.getUri().equals(SHUTDOWN_COMMAND);<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的HttpServer做了一个最简单的功能,就是监听8080端口,等待客户端的连接.连接成功后,从socket中取出客户端发送的数据,封装成request对象.然后request把http的内容解析,得到要请求的资源.再创建一个response对象,把要返回的数据封装好,通过socket发送给客户端.这就是一个最简单的服务器原型.</p><h2 id="一个简单的servlet容器"><a href="#一个简单的servlet容器" class="headerlink" title="一个简单的servlet容器"></a>一个简单的servlet容器</h2><p>下面就开始编写一个servlet类来测试.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在书中的servlet接口也是这样定义,4.1版本和9.0版本都是一样的.可以看出这种顶层接口在设计时候有多么的重要.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Servlet</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException;<br>    <br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span>;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当servlet的一个客户端请求到达后，servlet容器就调用相应的servlet的service()方法，并将servletRequest对象和servletResponse对象作为参数传人。ServletRequest对象包含客户端的HTTP请求的信息，ServletResponse对象则封装servlet的响应信息。在servlet对象的整个生命周期内，service()方法会被多次调用.这里的servlet容器就是我们前面的HttpServer类.</p><p>下面从servlet容器的角度审视servlet程序的开发。</p><ul><li>当第一次调用某个servlet时，要载入该servlet类，并调用其init()方法（仅此一次);</li><li>针对每个request请求，创建一个javax.servlet.ServletRequest实例和一个javax.servlet.ServletResponse 实例;</li><li>调用该servlet的service()方法，将servletRequest对象和servletResponse对象作为参数传入;</li><li>当关闭该servlet类时，调用其destroy()方法，并卸载该servlet类。</li></ul><p>本章所要建立的servlet容器是一个很小的容器，没有实现所有的功能。因此，它只能运行非常简单的servlet，而且也会不调用servlet的init()和destroy()方法。它会做以下几件事:</p><ul><li>等待HTTP请求;</li><li>创建一个servletRequest对象和一个servletResponse对象;</li><li>若请求的是一个静态资源，则调用StaticResourceProcessor对象的process()方法，传入servletRequest对象和servletResponse对象;</li><li>若请求的是servlet，则载入相应的servlet类，调用其service方法，传入servletRequest对象和servletResponse对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServer1</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SHUTDOWN_COMMAND</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/SHUTDOWN&quot;</span>;<br>  <span class="hljs-comment">// the shutdown command received</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">shutdown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">HttpServer1</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServer1</span>();<br>    server.await();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      serverSocket =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port, <span class="hljs-number">1</span>, InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>      System.exit(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Loop waiting for a request</span><br>    <span class="hljs-keyword">while</span> (!shutdown) &#123;<br>      <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">OutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        socket = serverSocket.accept();<br>        input = socket.getInputStream();<br>        output = socket.getOutputStream();<br><br>        <span class="hljs-comment">// create Request object and parse</span><br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(input);<br>        request.parse();<br><br>        <span class="hljs-comment">// create Response object</span><br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(output);<br>        response.setRequest(request);<br><br>        <span class="hljs-comment">// check if this is a request for a servlet or a static resource</span><br>        <span class="hljs-comment">// a request for a servlet begins with &quot;/servlet/&quot;</span><br>        <span class="hljs-keyword">if</span> (request.getUri().startsWith(<span class="hljs-string">&quot;/servlet/&quot;</span>)) &#123;<br>            <span class="hljs-comment">//ServletProcessor1就是一个serlet容器,它会调用我们自定的servlet类</span><br>          <span class="hljs-type">ServletProcessor1</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletProcessor1</span>();<br>          processor.process(request, response);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-type">StaticResourceProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticResourceProcessor</span>();<br>          processor.process(request, response);<br>        &#125;<br><br>        <span class="hljs-comment">// Close the socket</span><br>        socket.close();<br>        <span class="hljs-comment">//check if the previous URI is a shutdown command</span><br>        shutdown = request.getUri().equals(SHUTDOWN_COMMAND);<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        System.exit(<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该类的await()方法会一直等待HTTP请求，直到接收到一条关闭命令，这点与第Ⅰ章中的await()方法类似。区别在于，本章中的 await()方法可以将HTTP请求分发给StaticResourceProcessor对象或ServletProcessor对象来处理。当URI包含字符串“Iservlet/”时，会把请求转发给servletProcessor对象处理。否则的话，把HTTP请求传递给StaticResourceProcessor对象处理。</p><p>什么意思呢?现在的这个servlet容器并不智能,我们现在写的sevlet类名比如叫PrimitiveServlet,我们只需要在web.xml文件中配置映射路径,即使访问的是/hello或者/aaa这个url也可以映射到HelloServlet这个类.</p><p>但是这个不一样,没有xml文件的配置,如果我们向访问一个servler类,必须显示的指定一个url(/servlet/我们自己定义的servlet的类名),只有访问这个固定格式的url才可以调用到我们自己写的servlet(下面会具体解释).从这里可以感觉到这种最初的开发过程的美妙,什么都没有,没有xml的配置,只有一个自定义的servlet被调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ex02.pyrmont;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletProcessor1</span> &#123;<br>    <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Request request, Response response)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getUri();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">servletName</span> <span class="hljs-operator">=</span> uri.substring(uri.lastIndexOf(<span class="hljs-string">&quot;/&quot;</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>   <br>        <span class="hljs-comment">//下面这一堆就是解析url,得到类名,去仓库找到这个类.在整本书中,仓库指的是类载入器查找servlet类的目录</span><br>      URL[] urls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[<span class="hljs-number">1</span>];<br>      <span class="hljs-type">URLStreamHandler</span> <span class="hljs-variable">streamHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">File</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(Constants.WEB_ROOT);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">repository</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file&quot;</span>, <span class="hljs-literal">null</span>, classPath.getCanonicalPath() + File.separator)).toString() ;<br>      urls[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-literal">null</span>, repository, streamHandler);<br>      loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(urls);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      System.out.println(e.toString() );<br>    &#125;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">myClass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      myClass = loader.loadClass(servletName);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>      System.out.println(e.toString());<br>    &#125;<br><br>    <span class="hljs-type">Servlet</span> <span class="hljs-variable">servlet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//创建实例对象</span><br>      servlet = (Servlet) myClass.newInstance();<br>        <span class="hljs-comment">//调用这个实例对象的service方法</span><br>      servlet.service((ServletRequest) request, (ServletResponse) response);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      System.out.println(e.toString());<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>      System.out.println(e.toString());<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来解释一下 processor.process(request, response);</p><p><strong>HelloServer接收到客户端发来的请求:比如/servlet/PrimitiveServlet,其中PrimitiveServlet是我们自定义的servlet类.processor.process(request, response)就是,通过得socket传入的request对象,解析url,得到需要访问的类名.这里就是PrimitiveServlet.得到PrimitiveServlet的类名后,就要去指定的根目录下寻找这个类的位置,找到这个类的完整路径后,使用类加载器加载这个类,才能创建出PrimitiveServlet的一个实例对象.在把这个实例对象转成servlet类型,最后调用它的service方法.看到这里,就明白了为什么在tomcat中的java类要放在固定的路径下,因为只有放在固定的路径下,类加载器才能找打到这个类,才能创建处它的实例对象.为什么要实现servlet这个接口?因为它会向上转型成servlet</strong></p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><blockquote><p>如果上面的案例没有看懂,那么下面的将会很吃力.所以请务必看懂上面的案例再继续阅读</p></blockquote><p>正如前言所述，Catalina中有两个主要的模块，连接器(connector）和容器（container)。在本章中，将会建立一-个连接器来增强第⒉章中的应用程序的功能，用一种更好的方法来创建request对和response对象。在第2章中，servlet容器仅仅能运行实现了servlet接口的servlet容器，并把servletRequest实例和servletResponse实例传递给service方法。因为连接器并不知道servlet对象的类型（即不知道该servlet对象是实现了Servlet接口，还是继承自GenericServlet类或HttpServlet类)，连接器总是会提供HttpServletRequest实例和HttpServletResponse实例。</p><p><strong>在本章的应用程序中，连接器解析HTTP请求头，使servlet实例能够获取到请求头、cookie和请求参数/值等信息。</strong>可以修改第⒉章中Response类的getWriter()方法,使其可以工作得更好些。有了这些增强功能之后，就可以从PrimitiveServlet实例(就是一个自定义的servlet类)中获得完整的响应信息了，从而可以运行更加复杂一点的servlet类（例如ModernServlet)。本章中所要建立的连接器实际上是Tomcat 4中的默认连接器的<strong>简化版默认连接器</strong>将会在第4章中讨论。</p><p>本章的导读部分意思是,把Catalina拆开讲解.连接器就是用来等待客户端连接,解析从socket中得到的原始数据,创建request对象和response对象.让servlet实例可以得到请求头,cookie等信息.因为前面的部分只是简单的解析了url,并没有解析http的其余内容.容器就是上一章提到的HttpServer1,它负责调用类加载器,实例化自定义的servlet类.然后调用它的service()方法.</p><h3 id="StringMannager的单例模式"><a href="#StringMannager的单例模式" class="headerlink" title="StringMannager的单例模式:"></a>StringMannager的单例模式:</h3><p>像Tomcat这样的大型应用程序必须小心仔细地处理错误消息。在Tomcat中，错误消息对系统管理员和servlet程序员来说都是很有用的。例如，系统管理员可以很容易地根据Tomcat的错误日志消息定位到发生异常的位置。而对于servlet程序员来说，在抛出的每个javax.servlet.servletException异常中，Tomcat都会发送一条特殊的错误消息，这样，程序员就可以知道servlet程序到底哪里出错了。Tomcat 处理错误消息的方法是将错误消息存储在一个properties文件中，便于读取和编辑。但是Tomcat中有几百个类。若是将所有类使用的错误消息都存储在一个大的properties属性文件中，并维护这个文件将会是一场噩梦。为了避免这种情况，Tomcat将properties文件划分到不同的包中。例如，org.apache.catalina.connector包下的properties 属性文件包含该包中任何类可能抛出的所有的异常消息。每个properties文件都是用org.apache.catalina.util.StringManager类的一个实例来处理的。当Tomcat运行时，会产生StringManager类的很多实例，每个实例都会读取某个包下的指定properties文件。此外，由于Tomcat非常受欢迎，因此对错误消息进行国际化处理也是有必要的，当前共有三种语言得到支持。使用英文版错误消息的properties文件命名为LocalStrings.properties。其他两种语言是西班牙语和日语，错误消息文件分别名为LocalStrings_es.properties和LocalStrings ja.properties。当包中的某个类需要在其包内的properties文件中查找错误消息时，它会先获取对应的StringManager实例。但是，同一个包下的许多类会使用同一个StringManager实例，若是为每个要查找错误消息的对象创建一个StringManger实例是很浪费资源的。因此，设计StringManager类以便StringManager类的实例被包内所有的对象共享。若你对设计模式比较熟悉的话，你可能已经猜到了，StringManager是单例类。StringManager只有一个私有的构造函数，这样就不能在类的外部通过关键字new来实例化它了。只能通过调用其公共静态方法getManager()来获得其实例，该方法需要一个指明了包名的参数。每个StringManager实例都会以这个包名作为其键，存储在一个 Hashtable 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Hashtable managers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> StringManager <span class="hljs-title function_">getManager</span><span class="hljs-params">(String pacakgeName)</span>&#123;<br>    StringManager mgr=(StringManager)managers.get(pacakgeName);<br>    <span class="hljs-keyword">if</span> (mgr==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//现在的是私有的构造方法了,这是书中的.</span><br>        mgr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringManager</span>(pacakgeName);<br>        managers.put(pacakgeName,mgr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mgr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一个应用程序"><a href="#一个应用程序" class="headerlink" title="一个应用程序:"></a>一个应用程序:</h3><ol><li><p>启动器,相当于一个入口类.从这里开始就一点点解耦,把模块进行拆分了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ex03.pyrmont.startup;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bootstrap</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">HttpConnector</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpConnector</span>();<br>    connector.start();<br>  &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HttpConnector.主要就是监听8080端口,等待客户端的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ex03.pyrmont.connector.http;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpConnector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>  <span class="hljs-type">boolean</span> stopped;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">scheme</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http&quot;</span>;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getScheme</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> scheme;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      serverSocket =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port, <span class="hljs-number">1</span>, InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>      System.exit(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stopped) &#123;<br>      <span class="hljs-comment">// Accept the next incoming connection from the server socket</span><br>      <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        socket = serverSocket.accept();<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-comment">//这个是http处理类.</span><br>      <span class="hljs-type">HttpProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpProcessor</span>(<span class="hljs-built_in">this</span>);<br>      processor.process(socket);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>);<br>    thread.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HttpProcessor.它的作用就是通过HttpConnector得到的socket:</p><ol><li>创建request对象和response对象;</li><li>同时解析http请求的第一行内容和请求头的信息,将这些信息填充到request中.</li><li>把request对象和response对象传递给我们自定义的servlet类或静态资源处理类.与上面一章所说的是一样的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ex03.pyrmont.connector.http;<br><br><span class="hljs-comment">/* this class used to be called HttpServer */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpProcessor</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Socket socket)</span> &#123;<br>    <span class="hljs-type">SocketInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      input = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketInputStream</span>(socket.getInputStream(), <span class="hljs-number">2048</span>);<br>      output = socket.getOutputStream();<br><br>      <span class="hljs-comment">// create HttpRequest object and parse</span><br>      request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequest</span>(input);<br><br>      <span class="hljs-comment">// create HttpResponse object</span><br>      response = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpResponse</span>(output);<br>      response.setRequest(request);<br><br>      response.setHeader(<span class="hljs-string">&quot;Server&quot;</span>, <span class="hljs-string">&quot;Pyrmont Servlet Container&quot;</span>);<br><br>        <span class="hljs-comment">//这两个就是真正解析Http了,它会解析请求行,请求头,,解析cookie,获取请求参数一系列内容.都在这个类中,但是这里没有贴出来</span><br>      parseRequest(input, output);<br>      parseHeaders(input);<br>      <span class="hljs-keyword">if</span> (request.getRequestURI().startsWith(<span class="hljs-string">&quot;/servlet/&quot;</span>)) &#123;<br>        <span class="hljs-type">ServletProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletProcessor</span>();<br>        processor.process(request, response);<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">StaticResourceProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticResourceProcessor</span>();<br>        processor.process(request, response);<br>      &#125;<br><br>      <span class="hljs-comment">// Close the socket</span><br>      socket.close();<br>      <span class="hljs-comment">// no shutdown for this application</span><br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>其中书中有详细介绍了解析http的过程.但是因为实在是太多了,没有贴出来的必要,这里只是做一个架构的认识.本章的话主要就是进行了业务模块的拆分.还有把http的内容解析了.这样servlet就可以通过request的getParameter等方法得到想要的信息了.</p></li></ol><p>到这里的话,应该对于servlet 的整体工作流程有了一个基本的认识.对servlet和tomcat也有了更多的理解.本来还想继续写下去,但是后面内容比较复杂,书中讲的都十分详细.也不可能大片大片的粘贴原文.所以如果有兴趣的,真的很建议看原书!!</p>]]></content>
    
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>Tomcat</tag>
      
      <tag>servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/maven/"/>
    <url>/maven/</url>
    
    <content type="html"><![CDATA[<p>文档来自：【2021最新Maven超详细教程_Maven基础实战入门-哔哩哔哩】 <a href="https://b23.tv/fzCmCfN">https://b23.tv/fzCmCfN</a></p><h1 id="Maven-自动化的构建工具"><a href="#Maven-自动化的构建工具" class="headerlink" title="Maven 自动化的构建工具"></a>Maven 自动化的构建工具</h1><h1 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h1><h2 id="1-1-软件开发中的阶段"><a href="#1-1-软件开发中的阶段" class="headerlink" title="1.1 软件开发中的阶段"></a>1.1 软件开发中的阶段</h2><p>需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。</p><p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p><p>开发阶段：编码实现功能。 编译代码。自我测试</p><p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p><p>项目的打包，发布阶段： 给用户安装项目</p><h2 id="1-2-Maven能做什么"><a href="#1-2-Maven能做什么" class="headerlink" title="1.2 Maven能做什么"></a>1.2 Maven能做什么</h2><p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。</p><p>2）管理依赖（管理项目中使用的各种jar包）。</p><p>​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p><h2 id="1-3-没有使用maven怎么管理依赖"><a href="#1-3-没有使用maven怎么管理依赖" class="headerlink" title="1.3 没有使用maven怎么管理依赖"></a>1.3 没有使用maven怎么管理依赖</h2><p>管理jar ，需要从网络中单独下载某个jar 。需要选择正确版本。手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。</p><h2 id="1-4-什么是maven"><a href="#1-4-什么是maven" class="headerlink" title="1.4 什么是maven"></a>1.4 什么是maven</h2><p>maven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]  或  [‘mevn]。</p><p>maven是项目的自动化构建工具。 管理项目的依赖。</p><h2 id="1-6-maven工具的获取和安装"><a href="#1-6-maven工具的获取和安装" class="headerlink" title="1.6 maven工具的获取和安装"></a>1.6 maven工具的获取和安装</h2><p>地址： <a href="http://maven.apache.org/">http://maven.apache.org/</a>  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip</p><p>安装：</p><ol><li><p>确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录</p></li><li><p>解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 </p><p>目录的路径不要有中文， 不要有空格。</p></li><li><p>把maven安装目录中下的bin的路径添加到path中</p></li><li><p>测试maven的安装。 在命令行执行 mvn     -v</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">C:\Users\NING MEI&gt;mvn -v<br>Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)<br>Maven home: D:\tools\apache-maven-3.3.9\bin\..<br>Java version: 1.8.0_101, vendor: Oracle Corporation<br>Java home: C:\Program Files\Java\jdk1.8.0_101\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;<br></code></pre></td></tr></table></figure></li></ol><p>其他安装方式：</p><ol><li><p>确定JAVA_HOME是否有效</p></li><li><p>在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录</p><p>M2_HOME=D:\tools\apache-maven-3.3.9</p></li><li><p>在path环境变量中，加入 %M2_HOME%\bin    </p></li><li><p>测试maven的安装，在命令行执行 mvn  -v</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">C:\Users\NING MEI&gt;mvn -v<br>Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)<br>Maven home: D:\tools\apache-maven-3.3.9\bin\..<br>Java version: 1.8.0_101, vendor: Oracle Corporation<br>Java home: C:\Program Files\Java\jdk1.8.0_101\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Maven的核心概念"><a href="#Maven的核心概念" class="headerlink" title="Maven的核心概念"></a>Maven的核心概念</h1><h2 id="2-1-约定的目录结构"><a href="#2-1-约定的目录结构" class="headerlink" title="2.1 约定的目录结构"></a>2.1 约定的目录结构</h2><p>maven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。</p><p>一个maven项目是一个文件夹。 比如项目叫做Hello</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Hello 项目文件夹<br>    \src<br>    \main叫做主程序目录（完成项目功能的代码和配置文件）<br>             \java          源代码（包和相关的类定义）<br>     \resources    配置文件<br>    \test               放置测试程序代码的（开发人员自己写的测试代码）<br>     \java          测试代码的（junit）<br>     \resources     测试程序需要的配置文件<br>    \pom.xml                maven的配置文件， 核心文件<br></code></pre></td></tr></table></figure><p>maven的使用方式：</p><p>1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等</p><p>2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等</p><h2 id="2-2-POM"><a href="#2-2-POM" class="headerlink" title="2.2 POM"></a>2.2 POM</h2><ul><li>POM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。</li></ul><ul><li>maven通过pom.xml文件实现 项目的构建和依赖的管理。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-comment">&lt;!-- project是根标签， 后面的是约束文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <br>    <br>  <span class="hljs-comment">&lt;!-- pom模型的版本， 就是4.0.0 --&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 坐标 SNAPSHOT为快照版本，release为稳定版本--&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-3-坐标"><a href="#2-3-坐标" class="headerlink" title="2.3 坐标"></a>2.3 坐标</h2><ul><li>坐标组成是 groupid, artifiactId, version。坐标概念来自数学。</li></ul><ul><li>坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>groupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。<br>         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode<br><br>         如果项目规模比较大， 也可以是 域名倒写+大项目名称。<br>     例如： www.baidu.com ,  无人车： com.baidu.appollo<br>artifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。<br>version：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。<br>         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      <br>   <br>packaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar<br></code></pre></td></tr></table></figure><p>项目使用gav：</p><ol><li><p>每个maven项目，都需要有一个自己的gav</p></li><li><p>管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p></li><li><p>搜索坐标的地址： <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></li></ol><h2 id="2-4-依赖-dependency"><a href="#2-4-依赖-dependency" class="headerlink" title="2.4 依赖 dependency"></a>2.4 依赖 dependency</h2><ul><li>依赖：项目中要使用的其他资源（jar）。  </li></ul><ul><li>需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用</li></ul><ul><li>需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。</li></ul><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <br>    <span class="hljs-comment">&lt;!-- 日志 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span> <br><br>maven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar<br></code></pre></td></tr></table></figure><h2 id="2-5-仓库"><a href="#2-5-仓库" class="headerlink" title="2.5 仓库"></a>2.5 仓库</h2><p>仓库是存东西的，maven的仓库存放的是：</p><ol><li><p>maven工具自己的jar包。</p></li><li><p>第三方的其他jar， 比如项目中要使用mysql驱动。</p></li><li><p>自己写的程序，可以打包为jar 。 存放到仓库。</p></li></ol><p>仓库的分类：</p><ol><li><p>本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。</p><p>本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">C:\Users\NING MEI\.m2\repository<br></code></pre></td></tr></table></figure><p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\conf\setting.xml）</p><p>​    步骤：</p><p>​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。</p><p>​           例如： D:\openrepository</p><p>​     2）修改setting.xml文件，指定 D:\openrepository这个目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:/openrepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>远程仓库： 需要通过联网访问的</p><p>1）中央仓库： 一个ftp服务器， 存放了所有的资源。 </p><p>2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。</p><p>3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。</p></li></ol><p><strong>maven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。</strong></p><h2 id="2-6-maven的生命周期，插件和命令"><a href="#2-6-maven的生命周期，插件和命令" class="headerlink" title="2.6 maven的生命周期，插件和命令"></a>2.6 maven的生命周期，插件和命令</h2><ul><li>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署</li></ul><ul><li>插件：<strong>要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。</strong></li></ul><ul><li>命令： 执行maven功能是 由命令发出的。 比如 mvn compile</li></ul><p>单元测试（junit）：</p><p>junit是一个单元测试的工具， 在java中经常使用。</p><ul><li>单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。</li></ul><ul><li>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</li></ul><p>使用单元测试：</p><p>1）加入junit的依赖（一些类和方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>2)在src/test/java 目录中创建测试类文件。 写测试代码</p><p>   单元测试使用的建议：</p><p>​    1.测试类的定义， 名称一般是Test+要测试的类名称</p><p>​    2.测试类它的包名和要测试的类包名一样。</p><p>​    3.在类中定义方法，要测试代码。</p><p>​       方法的定义：public方法， </p><p>​                               没有返回值</p><p>​                               方法名称自定义（建议 Test+测试的方法名称）</p><p>​                               方法没有参数</p><p>   4.在测试类中的方法，可以单独执行。 测试类也可以单独执行</p><p>   5.在方法的上面加入@Test</p><p>命令：</p><ol><li> mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。</li></ol><p>​      插件： maven-clean-plugin   ， 版本是 2.5</p><ol start="2"><li>mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。</li></ol><p>​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p><p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p><p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的                </p><p>​                                                             文件拷贝target/classes目录中。</p><ol start="3"><li>mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录</li></ol><p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p><p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的</p><ol start="4"><li>mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。</li></ol><p>​     插件： maven-surefire-plugin 版本 2.12.4</p><ol start="5"><li>mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。</li></ol><p>​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.</p><p>​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。</p><p>​    生成的是 ch01-maven-1.0-SNAPSHOT.jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>打包的文件名： artifactId-version.packaging<br></code></pre></td></tr></table></figure><ol start="6"><li>mvn install : 把生成的打包的文件 ，安装到maven仓库。</li></ol><p>​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 </p><p>​    查看查看中的jar文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>groupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\bjpowernode<br>artifactId, 独立的文件夹<br>version，独立的文件夹<br></code></pre></td></tr></table></figure><h2 id="2-7-自定义配置插件"><a href="#2-7-自定义配置插件" class="headerlink" title="2.7 自定义配置插件"></a>2.7 自定义配置插件</h2><p>在pom.xml文件中， build标签中。设置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 设置构建项目相关的内容 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置插件 ,一个plugin就是一个插件，compliler默认使用的编译器是1.7--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span> <span class="hljs-comment">&lt;!-- 指定编译代码的jdk版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span> <span class="hljs-comment">&lt;!-- 运行java程序使用的jdk版本--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span> <br></code></pre></td></tr></table></figure><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>依赖范围：使用scope表示依赖的范围。 </p><p>依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。</p><p>依赖范围scope ：</p><p>​     compile: 默认， 参与构建项目的所有阶段</p><p>​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p><p>​     provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包</p><p>​                      明显的是servlet 和jsp 依赖。因为servlet这个依赖在tomcat中是有的。当web项目发布在Tomcat中时，会直接调用Tomcat中的servlet依赖。</p><p><strong>在本地仓库中的jar包，如果有以.lastUpload结尾的文件，那么就证明这个jar包是加载失败的，不能使用。因为如果你指定了一个不存在的版本，maven也会默认在仓库建一个文件夹。但是这个文件夹的内容是不可使用的</strong></p><h1 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h1><p>1)讲的是properties它里面的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span> 源码编译 jdk 版本<br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span> 运行代码的 jdk 版本<br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span> 项目构建使用的编码，避免中文乱码<br><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<br><span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span> 生成报告的编码<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>全局变量</li></ol><p>在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。 </p><p>使用全局变量表示 多个依赖使用的版本号。</p><p>使用步骤：</p><p>1.在properties标签中，定义一个标签，指定版本的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <br>  <span class="hljs-comment">&lt;!--自定义变量--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用全局变量， 语法 ${变量名}</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3）使用资源插件</p><p>处理的配置文件的信息， maven默认处理配置文件</p><p>①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下</p><p>②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。</p><p><strong>存放在java目录下有一些非.java文件，也要在编译时候拷贝到classes文件中，就要手动的配置maven的扫描规则。比如mybatis中的.xml文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--资源插件</span><br><span class="hljs-comment">      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-comment">&lt;!--所在的目录--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  filtering 选项 false 不启用过滤器， *.property 已经起到过</span><br><span class="hljs-comment">        滤的作用了 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="多模块聚合"><a href="#多模块聚合" class="headerlink" title="多模块聚合"></a>多模块聚合</h1><h3 id="以eladmin模块做介绍："><a href="#以eladmin模块做介绍：" class="headerlink" title="以eladmin模块做介绍："></a>以eladmin模块做介绍：</h3><p><a href="https://eladmin.vip/">ELADMIN 在线文档</a></p><p><img src="/blogImg/eladmin01.png" alt="eladmin01"></p><ul><li><p>项目有5个子模块，使用一个大的模块来进行管理。因为该父模块只用来管理这5个子模块，所以不需要任何的src文件或者java文件，只需要pom.xml文件来管理即可。所以在目录只有下有一个与五个模块同级的pom.xml文件。接下来介绍父工程中xml中标签的意义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--pom表示该工程只用于进行构建管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这里就是它要管理的模块，名字就是每个子模块的 &lt;artifactId&gt;eladmin-tools&lt;/artifactId&gt;里面的具体名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eladmin-common<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eladmin-logging<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eladmin-system<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eladmin-tools<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eladmin-generator<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--继承比如AB两个模块都需要同一个依赖，那么就可以在pom工程中统一定义，方便管理依赖版本的统一--&gt;</span><br><span class="hljs-comment">&lt;!--在这里统一定义依赖版本（节选了部分）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">log4j2.version</span>&gt;</span>2.17.0<span class="hljs-tag">&lt;/<span class="hljs-name">log4j2.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">logback.version</span>&gt;</span>1.2.9<span class="hljs-tag">&lt;/<span class="hljs-name">logback.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这里就是具体的依赖名称（节选了部分）--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Spring boot 核心--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Spring boot Web容器--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在pom文件中定义好父工程后，需要在子模块中定义父工程。以eladmn-system为例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--要在子模块中引入父工程，表示自己被父工程管理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eladmin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>me.zhengjie<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--因为group和版本都是和父工程统一的，所以这里只定义子模块id就行--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eladmin-system<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>核心模块<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--这里定义的依赖，表示只有该模块需要使用，因为都需要使用的在父工程已经定义好了--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jjwt.version</span>&gt;</span>0.11.1<span class="hljs-tag">&lt;/<span class="hljs-name">jjwt.version</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- oshi监控需要指定jna版本, 问题详见 https://github.com/oshi/oshi/issues/1040 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jna.version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">jna.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--因为该模块需要依赖另一个子模块，所以要引入 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>me.zhengjie<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eladmin-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--表示不需要引入eladmin-common。因为eladmin-generator依赖了eladmin-common，但是这里不需要--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>me.zhengjie<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eladmin-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- tools 模块包含了 common 和 logging 模块 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>me.zhengjie<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eladmin-tools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 打包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 跳过单元测试 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">skipTests</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skipTests</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p>需要注意的是，在A子模块中引入B子模块时，除了在dependency中添加B模块的坐标外，还需要install一下，这样才能把B模块加入到仓库中。A模块才可以使用 </p></li></ul><p><profile>表示设置不同的环境，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 创建多环境，比如开发，生产，测试环境--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--定义的具体环境：如开发环境--&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--环境的唯一名称--&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>pro_env<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>             <span class="hljs-comment">&lt;!--个性化的一些配置--&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>             <span class="hljs-comment">&lt;!--设置成默认的启动环境--&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!--具体环境2：如测试环境--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev_env<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="私服设置："><a href="#私服设置：" class="headerlink" title="私服设置："></a>私服设置：</h3><p>参考：【黑马程序员Maven全套教程，maven项目管理从基础到高级，Java项目开发必会管理工具maven-哔哩哔哩】<a href="https://b23.tv/qefN4Xn">https://b23.tv/qefN4Xn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Maven</tag>
      
      <tag>工具</tag>
      
      <tag>入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker入门</title>
    <link href="/docker%E5%85%A5%E9%97%A8/"/>
    <url>/docker%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/engine/install/centos/">docker官网地址</a></p><h4 id="基本组成："><a href="#基本组成：" class="headerlink" title="基本组成："></a>基本组成：</h4><ul><li>镜像：类似于类模板</li><li>容器: 类似于一个实例对象 就是用镜像run出来的一个一个的实例（类似于java类，new出来一个容器对象）。这个容器包括了需要运行的各种环境。从镜像容器角度看，容器相当于一个简易版的linux环境＋运行在其中的应用程序。</li><li>仓库：就是用来集中存放各种镜像的地方，需要的时候拉下来就行</li></ul><blockquote><p>1.理解docker的概念是很重要的。镜像就是一个模板，可以使用这个模板创建不同的实例。相当于：镜像 实例1=new 镜像()；镜像 实例2=new 镜像()。</p><p>2.关于下面的各种容器的创建，命令等。除了tomcat8没有远程连接测试之外，其它的配置文件和命令都亲测可用。但是用的linux是远程的云服务器，不是虚拟机！文章内容基于尚硅谷docker教程。</p></blockquote><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="centos7上安装："><a href="#centos7上安装：" class="headerlink" title="centos7上安装："></a>centos7上安装：</h3><p><a href="https://docs.docker.com/engine/install/centos/">docker官网地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">//从上往下直接复制就行<br>yum -y install gcc<br>yum -y install gcc-c++   //注意这里的-是连着的，没有空格<br>yum install -y yum-utils<br>yum-config-manager  --add-repo  http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo   //设置阿里云镜像<br>yum makecache fast<br>yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br><br>//启动docker <br>systemctl start docker<br>//执行这个命令，测试有没有hello word输出。多等一下，因为第一次本地没有<br>docker run hello-world<br></code></pre></td></tr></table></figure><h3 id="配置阿里云加速："><a href="#配置阿里云加速：" class="headerlink" title="配置阿里云加速："></a>配置阿里云加速：</h3><ol><li>注册一个阿里云账号：<a href="https://www.aliyun.com/product/acr?spm=5176.166170.J_3207526240.15.478d5164AJqJOA">阿里云地址：容器镜像服务_镜像构建_镜像授权_镜像托管-阿里云 (aliyun.com)</a></li><li>找到容器镜像服务：</li></ol><p><img src="/blogImg/dockerAli01.png" alt="image-20221114211646164"></p><ol start="3"><li><p>直接点击管理控制台，不要点购买</p><p><img src="/blogImg/dockerAli02.png" alt="image-20221114212020823"></p></li><li><p>在实例列表里面创建个人版</p></li><li><p>进入镜像工具-镜像加速器-CentOs，把下面内容粘贴（可能markdowan有格式问题，可以去官网复制）</p><p><img src="/blogImg/dockerAli03.png" alt="image-20221114212246829"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt; &lt; -&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://wglvozsd.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure></li><li><p>systemctl status docker               //查看docker状态</p></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="docker命令："><a href="#docker命令：" class="headerlink" title="docker命令："></a>docker命令：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">启动docker: systemctl start docker<br>停止docker: systemctl stop docker<br>重启docker：systemctl restart docker<br>查看docker状态: systemctl status docker <br>开机自启动: systemctl enable docker<br>查看概要信息：docker info<br>查看总体帮助文档：docker --help   <br>某一条命令帮助文档： docker 具体命令 --help<br><br></code></pre></td></tr></table></figure><h3 id="镜像命令："><a href="#镜像命令：" class="headerlink" title="镜像命令："></a>镜像命令：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">                name的前缀表示由于不同的组织发布的，official表示是否官方认证过的  <br>docker images   查看本地的镜像,注意是镜像，不是容器实例。 TAG表示镜像的标签版本号 使用镜像时候不指定Tag默认就是最新的版本<br>docker images -a   列出本地所以镜像 包括历史版本<br>docker images -q    只显示镜像ID<br>docker search redis（某个镜像的名字）  搜索镜像  <br>docker search --limit 5 redis    指定只看前几条数据，以star的数量排序<br><br>docker pull 镜像名字[:TAG]                 拉取镜像<br>docker pull redis:6.0.8<br>docker system df查看镜像/容器/数据卷占用的空间<br>docker rmi  ID/容器名字               根据id或者名字删除镜像<br>docker rmi -f 16ecd2772934  -f 强制删除镜像 <br><br></code></pre></td></tr></table></figure><blockquote><p>docekr的虚悬镜像指：REPOSITORY和TAG都为<none>的镜像</p><p>docker image ls -f dangling=true 查看所有虚悬镜像</p></blockquote><h3 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull ubuntu           下载一个ubuntu镜像<br>docker run -it ubuntu /bin/bash创建一个ubuntu容器实例，是实例！！相对于在docker装了个ubuntu系统，但只包含内核。如vim就没有<br>-it： 表示会返回一个终端输入，因为你启动了ubuntu之后，是有一个命令交互窗口来使用这个ubuntu吧<br>    -d:   表示后台运行容器（比如redis这种），it是前台类型。<br>    -p:   指定端口映射.因为访问docker内部的容器（如redis），需要先经过docker，在到redis<br>docker run -it --name=ubuntu  ubuntu  /bin/bash   指定容器的名字，不指定会随机分配（最好指定）<br>docker run -d --name=redis redis   创建一个redis实例<br><br><br>docker ps 显示容器实例<br>-a：列出当前所有正在运行的实例和历史运行过的<br>-I：显示最近创建的容器<br>-n：显示最近创建的n个<br>-q：静默模式，只显示容器编号<br><br><br><span class="hljs-built_in">exit</span> 退出容器。容器已经停止了<br>crl+p+q退出容器，后台还在运行<br>docker <span class="hljs-built_in">exec</span> -it 容器ID /bin/bash    重新进入容器,（容器没有停止）<br><br>docker start 容器ID/容器名字启动已经停止的容器<br>docker restart 容器ID/容器名字     重启<br>docker stop   容器ID/容器名字         停止<br>docker <span class="hljs-built_in">kill</span>    容器ID/容器名字     强制停止<br>docker <span class="hljs-built_in">rm</span>  容器ID/容器名字         删除已停止的容器（-f 强制）加i为删除镜像<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"> docker inspect 容器ID    进入正在运行的容器并以命令进行交互<br> docker <span class="hljs-built_in">exec</span>/attach -it  容器<span class="hljs-built_in">id</span>  bashShell   <br> attach：直接进入容器终端，不会启动新的进程，用<span class="hljs-built_in">exit</span>退出容器会停止<br> <span class="hljs-built_in">exec</span>：打开的是新的终端，启动新的进程，<span class="hljs-built_in">exit</span>退出容器不会停止<br>如：<br>  docker <span class="hljs-built_in">exec</span> -it 1190c106fda3  /bin/bash      进入redis容器<br>  redis-cli -p 6379开启一个客户端<br>  <span class="hljs-built_in">set</span> k1 v1                 成功<br><br><br>docker <span class="hljs-built_in">cp</span> 容器<span class="hljs-built_in">id</span>：容器内路径  目的主机路径       从容器内拷贝文件<br>docker <span class="hljs-built_in">export</span> 容器ID &gt; 文件名字.tar    导出容器内容作为一个tar归档文件<br><span class="hljs-built_in">cat</span> 文件名.tar | docker import - 镜像用户/镜像名字：镜像版本号       将tar包内容变成一个镜像（接下来就可以使用这个镜像了）<br><br></code></pre></td></tr></table></figure><blockquote><p>redis服务端只会接收来自客户端的命令，因为在redis启动时候，也是开启一个伪客户端来发送命令实现数据恢复的  参照《redis设计与实现》</p></blockquote><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>是什么：</p><p>分层的镜像：</p><p>UnionFS（联合文件系统）：</p><p>镜像加载原理</p><p>为什么分层：</p><p><strong>Docker镜像层都是只读的，容器层是可写的。当容器启动时候，一个新的可写层被加载到镜像的顶部。这一层通常被称为“容器层”。容器层之下的都叫“镜像层”</strong></p><h3 id="Commit命令："><a href="#Commit命令：" class="headerlink" title="Commit命令："></a>Commit命令：</h3><p>从上面我们可以得知，ubuntu只包含了最需要的内核。比如vim就没有。而我们可以自己在创建的容器中安装vim，然后把这个安装了vim的容器变成一个新的镜像，这样以后我们通过这个新的镜像创建出来的容器就具有了vim的功能.这就是复用,分层。需要什么，我们就加什么，加了之后以后就可以生成一个自定义的镜像，使用这个镜像就能创具有出自定义功能的实例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get update        更新包管理工具（ubuntu系统）<br>apt-get -y install vim  安装vim<br>vim a.txt 这时候就可以使用vim了<br>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID  要创建的目标镜像名字：标签名<br><br>docker ps 先查看一下容器ID<br>docker commit -m=&quot;具有vim的ubuntu&quot; -a=&quot;atiguigu&quot; f0f78f34f242  atguigu/myubuntu:1.3    （）<br>docker images       可以看到有一个新的image镜像，名字叫atguigu/myubuntu，而且大小变成了180M<br>docker run -it d90677247fd6 /bin/bash    创建这个心镜像的名字，输入<br>cat  a.txt      命令可以正常使用（如果上面创建了a.txt,里面有内容，这里会输出内容）<br><br><br></code></pre></td></tr></table></figure><h3 id="发布镜像到阿里云"><a href="#发布镜像到阿里云" class="headerlink" title="发布镜像到阿里云"></a>发布镜像到阿里云</h3><ol><li><p>打开上面容器镜像的控制台。进入实例列表。点击个人实例</p></li><li><p>创建一个命名空间，仓库类型设置为公开（类似于一个包名）</p></li><li><p>点击镜像仓库，创建一个镜像仓库。名字自取</p></li><li><p>点击仓库名称，可以看到一个操作指南。找到第三步，将镜像推送到registry，直接复制，修改为自己的镜像tag等。需要知道自己的阿里云名字，仓库名字，所以要去去阿里云自己复制。拉取时候我们可以看见只用填版本号。所以一个镜像仓库应该是对应一种镜像的不同版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">//推送commit。<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login --username=随便打个名字111 registry.cn-zhangjiakou.aliyuncs.com</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag [ImageId] registry.cn-zhangjiakou.aliyuncs.com/ciyx/myubuntu:[镜像版本号]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push registry.cn-zhangjiakou.aliyuncs.com/ciyx/myubuntu:[镜像版本号]</span><br><br>//登录<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login --username=随便打个名字111 registry.cn-zhangjiakou.aliyuncs.com</span><br>//拉取<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull registry.cn-zhangjiakou.aliyuncs.com/ciyx/myubuntu:[镜像版本号]</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="推送到私有云："><a href="#推送到私有云：" class="headerlink" title="推送到私有云："></a>推送到私有云：</h3><p>由于网络原因：需要的请参考尚硅谷视频：（docker教程天花板）<a href="https://b23.tv/uT8Uz1q">https://b23.tv/uT8Uz1q</a></p><hr><h2 id="docker容器数据卷"><a href="#docker容器数据卷" class="headerlink" title="docker容器数据卷"></a>docker容器数据卷</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System。提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。就是指定一个文件映射关系，将容器内的数据持久化到主机上的磁盘中。类似于redis的aop和aof，这样即使容器被删了，数据也可以重新恢复</p><h3 id="设置："><a href="#设置：" class="headerlink" title="设置："></a>设置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录  镜像名字<br>-it：前台启动<br>--privileged=true 设置为root访问权限，防止某些目录没有操作权限<br>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro  镜像名字<br>:ro表示容器只能读宿主机文件信息，不能写文件。<br>docker inspect 容器ID  查看容器信息，如果挂载成功，里面的Mounts属性显示了数据卷的映射关系<br><br></code></pre></td></tr></table></figure><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li><p>数据卷可在容器之间共享或重用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --privileged=true --volumes- from 父容器  子容器名字<br>如果父容器挂了，子容器数据卷并不会有影响，因为继承的是挂载的规则。<br>如果父容器重启，会继续使用这个挂载<br></code></pre></td></tr></table></figure></li><li><p>容器中更改可以直接实时生效，自动备份到数据卷中，不用人为的cp。主机目录下新建的文件数据会被同步到容器，容器建立的文件也会同步到宿主主机是一个双向的备份。如果容器停了，但是宿主机还在新增数据，容器重启后数据还是会同步！！</p></li><li><p>数据卷中的更改不会包括在镜像的更新中</p></li><li><p>数据卷的生命周期一直持续到没有容器使用为止</p></li></ol><h2 id="docker常规的软件安装"><a href="#docker常规的软件安装" class="headerlink" title="docker常规的软件安装"></a>docker常规的软件安装</h2><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull billygoo/tomcat8-jdk8   安装8.0版本<br>docker run -it -p 8080:8080  --name=tomcat  billygoo/tomcat8-jdk8     启动（以前台方式）<br>   -d: 后台启动<br>如果是云服务器，就访问ip：8080看看是否有tomcat主页。记得去云控制台开放端口。最新版的tomcat需要修改一些东西，所以请下载tomcat8<br><br>docker exec -it  a0c1e994a083   /bin/bash   进入tomcat的根目录<br></code></pre></td></tr></table></figure><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>简单版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql:5.7<br>docker run -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7       因为自己服务器已经开过mysql了，所以这里开3307<br>docker exec -it c877679e1900 /bin/bash   进入控制台<br>mysql -uroot -p    连接mysql<br><br>用本地navicat连接测试，云服务器的记得开安全组，端口就是上面写的3307。创建一个表，插入带有中文的数据，会有乱码<br><br>show variables like &#x27;character%&#x27;；   在docker容器中的mysql控制台，查看编码，是拉丁文。所以要设置一下（不能再本地navicat上查看）<br> <br> <br></code></pre></td></tr></table></figure><p>正式版：因为上面没有设置容器卷，会有数据丢失问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shel"><br>docker run -p 3307:3306 --name mysql \<br>--privileged=true -v /mydata/mysql/log:/var/log/mysql \<br>-v /mydata/mysql/data:/var/lib/mysql \<br>-v /mydata/mysql/conf:/etc/mysql \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>-d mysql:5.7<br><br><br>#进入conf目录，新建配置文件，通过这个配置文件传递给docker中的mysql解决乱码（不知道8.0有没有）<br>vim my.cnf   填入下面的内容<br><br>[client]<br>default_character_set=utf8<br>[mysqld]<br>collation_server=utf8_general_ci<br>character_set_server=utf8<br><br>重启mysql<br>docker restart mysql<br></code></pre></td></tr></table></figure><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redsi:6.0.8     没有镜像稍等一下，它会自己下载<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 创建目录</span></span><br>mkdir -p /home/redis/conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 创建文件</span></span><br>touch /home/redis/conf/redis.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">下面是run命令，直接复制 \表示换行</span><br>docker run \<br>--privileged=true --name redis \<br>-p 6379:6379 \<br>-v /home/redis/data:/data \<br>-v /home/redis/conf/redis.conf:/etc/redis/redis.conf \<br>-d redis:6.0.8 \<br>redis-server /etc/redis/redis.conf <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ps：</span><br>http://download.redis.io/redis-stable/  redis的配置文件下载，然后呢把文件内容复制到/home/redis/conf/redis.conf里面<br>这个redsi.conf好像是已经修改好了的，直接使用就用。在本地用一个redis客户端连接一下，成功！！！<br><br><br></code></pre></td></tr></table></figure><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="docker复杂安装"><a href="#docker复杂安装" class="headerlink" title="docker复杂安装"></a>docker复杂安装</h2><p>跳过redis和mysql的主从复制安装，需要的观看尚硅谷教程：</p><p>【尚硅谷2022版Docker实战教程（docker教程天花板）-哔哩哔哩】 <a href="https://b23.tv/IEwZA1H">https://b23.tv/IEwZA1H</a></p><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。类似于commit。</p><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><h3 id="大致流程："><a href="#大致流程：" class="headerlink" title="大致流程："></a>大致流程：</h3><p>（1）docker从基础镜像运行一个容器</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似docker commit的操作提交一个新的镜像层</p><p>（4）docker再基于刚提交的镜像运行一个新容器</p><p>（5）执行dockerfile中的下一条指令直到所有指令都执行完成</p><h3 id="常用保留字指令："><a href="#常用保留字指令：" class="headerlink" title="常用保留字指令："></a>常用保留字指令：</h3><p>FROM：基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p><p>RUN：容器构建时需要运行的命令。shell格式，exec格式。RUN是在 docker build时运行</p><p>EXPOSE：当前容器对外暴露出的端口</p><p>WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p><p>USER：指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p><p>ENV:用来在构建镜像过程中设置环境变量. ENV MY_PATH /usr/mytest这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量    前缀一样；也可以在其它指令中直接使用这些环境变量， 比如：WORKDIR $MY_PATH</p><p>ADD:将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包，类似copy加解压</p><p>COPY:类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p><p>VOLUME:容器数据卷，用于数据保存和持久化工作</p><p>CMD：Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换。Dockerfile 中可以有多个 CMD 指令，但只    有最后一个生效，CMD 会被 docker run 之后的参数替换。CMD是在docker run 时运行。ENTRYPOINT：类似于 CMD 指令，但是ENTRYPOINT不会被    docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><table><thead><tr><th>是否传参</th><th>按照dockerfile编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run nginx:test</td><td>docker run nginx:test -c /etc/nginx/new.conf</td></tr><tr><td>衍生出的实际命令</td><td>nginx -c /etc/nginx/nginx.conf</td><td>nginx -c /etc/nginx/new.conf</td></tr></tbody></table><h3 id="构建一个自己的centos："><a href="#构建一个自己的centos：" class="headerlink" title="构建一个自己的centos："></a>构建一个自己的centos：</h3><ul><li>安装jdk8,vim,ipconfig</li></ul><p>jdk-8u171-linux-x64.tar.gz下载：<a href="https://mirrors.yangxingzhen.com/jdk/">https://mirrors.yangxingzhen.com/jdk/</a> </p><ol><li>创建一个目录，里面新建一个Dockerfile文件，只能是这个名字。把下载的jdk包放在同级文件夹下</li><li>编辑 Dockerfile，粘贴下面代码 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这里要拉取7版本的centos才行，不是的先docker pull centos:7。</span><br> FROM centos:7<br> MAINTAINER code<br> ENV MYPATH /usr/local<br> WORKDIR $MYPATH <br><span class="hljs-meta prompt_"> #</span><span class="language-bash">安装vim编辑器。Run就是运行后面的这个命令</span><br> RUN yum -y install vim<br><span class="hljs-meta prompt_"> #</span><span class="language-bash">安装ifconfig命令查看网络IP</span><br> RUN yum -y install net-tools<br><span class="hljs-meta prompt_"> #</span><span class="language-bash">安装java8及lib库,一个必备操作</span><br> RUN yum -y install glibc.i686<br> RUN mkdir /usr/local/java<br><span class="hljs-meta prompt_"> #</span><span class="language-bash">ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span><br> ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/<br><span class="hljs-meta prompt_"> #</span><span class="language-bash">配置java环境变量</span><br> ENV JAVA_HOME /usr/local/java/jdk1.8.0_171<br> ENV JRE_HOME $JAVA_HOME/jre<br> ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH<br> ENV PATH $JAVA_HOME/bin:$PATH <br> EXPOSE 80 <br><span class="hljs-meta prompt_"> #</span><span class="language-bash">上面说的多个CMD只有最后一个生效是在运行阶段，这里只是build阶段，所以三个都会生效</span><br> CMD echo $MYPATH<br> CMD echo &quot;success--------------ok&quot;<br> CMD /bin/bash <br> <br> <br></code></pre></td></tr></table></figure><ol start="3"><li><p>执行构建命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">centosjava8是自定义镜像名字，:后面是版本号。名字好像只能是小写。注意命令最后有个点</span><br>docker build -t centosjava8:1.5 .<br><br></code></pre></td></tr></table></figure></li><li><p>最后看到successfully就OK</p></li><li><p>docker images 查看生成的镜像。然后启动</p></li><li><p>测试vim，ipconfig，java -version 。全部成功。</p></li></ol><h3 id="发布boot："><a href="#发布boot：" class="headerlink" title="发布boot："></a>发布boot：</h3><ol><li>本地新建一个最简单的boot项目，不包含数据库和redsi。测试成功后打包上传到服务器。和Dockerfile放在同一个文件夹</li><li>填入下面内容。dockerBoot-0.0.1-SNAPSHOT.jar是我的jar名称</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">基础镜像使用java</span><br>FROM java:8<br><span class="hljs-meta prompt_"># </span><span class="language-bash">作者</span><br>MAINTAINER zzyy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span><br>VOLUME /tmp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将jar包添加到容器中并更名为zzyy_docker.jar</span><br>ADD dockerBoot-0.0.1-SNAPSHOT.jar zzyy_docker.jar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行jar包</span><br>RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;<br>ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">暴露8888端口</span><br>EXPOSE 8888 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">生成镜像</span><br>docker build -t zzyy_docker.jar:1.6 .   <br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行实例</span><br>docker run -d -p 8001:8888  1bdc37d39ec1 <br><span class="hljs-meta prompt_">#</span><span class="language-bash">访问ip，返回测试数据，成功。记得开放8001.8001是对外暴露的，8888是在docker容器内部的。</span><br></code></pre></td></tr></table></figure><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p><p> docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？ 如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具 例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。 Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>文档：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">傻瓜式安装，三个命令依次复制。因为github原因，很慢或者超时，耐心等待。新版的好像自带了compose，可以百度一下</span><br>curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; \<br>-o /usr/local/bin/docker-compose<br><br>chmod +x /usr/local/bin/docker-compose<br><br>docker-compose --version <br><span class="hljs-meta prompt_">#</span><span class="language-bash">出现docker-compose version 1.29.2, build 5becea4c就证明成功了</span><br></code></pre></td></tr></table></figure><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li></ol><p>写不下去了，命令很烦。而且主要是要自己会写dockerfile和compose命令，但是根本不会写，只看得懂。剩下给个传送门吧：</p><p>【尚硅谷2022版Docker实战教程（docker教程天花板）-哔哩哔哩】<a href="https://b23.tv/Jz7G4CS">https://b23.tv/Jz7G4CS</a></p><p>docker-compose.yml文件（尚硅谷的）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br> <span class="hljs-attr">microService:</span><br>   <span class="hljs-attr">image:</span> <span class="hljs-string">zzyy_docker:1.6</span><br>   <span class="hljs-attr">container_name:</span> <span class="hljs-string">ms01</span><br>   <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6001:6001&quot;</span><br>   <span class="hljs-attr">volumes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/app/microService:/data</span><br>   <span class="hljs-attr">networks:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">atguigu_net</span><br>   <span class="hljs-attr">depends_on:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>    <br> <span class="hljs-attr">redis:</span><br>   <span class="hljs-attr">image:</span> <span class="hljs-string">redis:6.0.8</span><br>   <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span><br>   <span class="hljs-attr">volumes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/app/redis/redis.conf:/etc/redis/redis.conf</span>    <br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/app/redis/data:/data</span>   <br>   <span class="hljs-attr">networks:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">atguigu_net</span>    <br>   <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">/etc/redis/redis.conf</span><br>                                                  <br> <span class="hljs-attr">mysql:</span>   <br>   <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>   <span class="hljs-attr">environment:</span>      <br>     <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">&#x27;123456&#x27;</span><br>     <span class="hljs-attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="hljs-string">&#x27;no&#x27;</span><br>     <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">&#x27;db2021&#x27;</span>  <br>     <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">&#x27;zzyy&#x27;</span>     <br>     <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">&#x27;zzyy123&#x27;</span>   <br>   <span class="hljs-attr">ports:</span>      <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span>   <br>   <span class="hljs-attr">volumes:</span>     <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/app/mysql/db:/var/lib/mysql</span>    <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/app/mysql/conf/my.cnf:/etc/my.cnf</span>    <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/app/mysql/init:/docker-entrypoint-initdb.d</span>  <br>   <span class="hljs-attr">networks:</span>      <br>     <span class="hljs-bullet">-</span> <span class="hljs-string">atguigu_net</span><br>   <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span>   <span class="hljs-comment">#解决外部无法访问 networks:    atguigu_net:</span><br>   <br></code></pre></td></tr></table></figure><h2 id="Portainer安装"><a href="#Portainer安装" class="headerlink" title="Portainer安装"></a>Portainer安装</h2><p>就是个可视化监控工具，可以不用写命令就启动容器。能监控服务器上的资源使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v \<br>/var/run/docker.sock:/var/run/docker.sock  \<br>-v portainer_data:/data  \<br>portainer/portainer <br><br>登录xxx.xxx.xxx.xxx:9000访问。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/java%E5%9F%BA%E7%A1%80/"/>
    <url>/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p><strong>可以在类声明时通过一个标识来表示类中某个属性的类型，或者是某个方法的返回值类型，或者是参数类型</strong>。就是相当于一个类型占位符。以前需要显示的指定某种数据的类型，现在可以用一个符号来代替。这样该变量的数据类型就不是固定的了！我们就可以根据实际需要，在创建对象的时候选择响应的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>      <br>Person&lt;String&gt; person1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;(<span class="hljs-string">&quot;code&quot;</span>);<br>            Person&lt;Integer&gt; person2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;(<span class="hljs-number">10010</span>);<br><br>    &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(T t)</span>&#123;<br>    <span class="hljs-built_in">this</span>.t=t;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setT</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getT</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">interfac 接口&lt;T,R,...&gt;&#123;&#125; 和  类class 类&lt;k,v,...&gt;&#123;&#125;<br><br><span class="hljs-keyword">private</span> T[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>];   (错误的定义)<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-comment">//错误的定义</span><br>    &#125;<br>因为静态属性是和类相关关的，在类加载时候对象还没有创建，并不知道具体类型是什么。所以无法初始化。<br></code></pre></td></tr></table></figure><ol><li><p>T,E等只能是引用类型</p></li><li><p>在指定泛型的具体类型后，构造器可以传入该类型或者它的子类类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>    Person&lt;A&gt; person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br>    Person&lt;A&gt; person2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>());<br><br>    &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(T t)</span>&#123;<br>    <span class="hljs-built_in">this</span>.t=t;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setT</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getT</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用泛型的数组，不能初始化</p></li><li><p>静态方法中不能使用类的泛型</p></li></ol><h3 id="泛型方法："><a href="#泛型方法：" class="headerlink" title="泛型方法："></a>泛型方法：</h3><p>修饰符 &lt;T,R,…&gt; 返回类型 方法名(参数列表){  }</p><ol><li><p>泛型方法<strong>可以定义在普通类中，也可以在泛型类中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>&lt;T,R&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">run1</span><span class="hljs-params">(T t,R r)</span>&#123;<br>        <span class="hljs-comment">//这是一个泛型方法</span><br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run2</span><span class="hljs-params">(T t,R r)</span>&#123;<br>        <span class="hljs-comment">//这个是使用了类定义的泛型</span><br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型方法，可以使用类声明的泛型，也可以使用自己声明的泛型。</p></li></ol><h3 id="泛型的继承和通配"><a href="#泛型的继承和通配" class="headerlink" title="泛型的继承和通配:"></a>泛型的继承和通配:</h3><ol><li>泛型不具备继承性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>   Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;code&quot;</span>);    <span class="hljs-comment">//T</span><br>   List&lt;Object&gt; list1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(); <span class="hljs-comment">//F 这样就是不可以的，不具备继承性</span><br>   List&lt;Object&gt; list2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   list2.add(<span class="hljs-string">&quot;kkk&quot;</span>)<br> &#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li><p>通配符的使用</p><ol><li>? 表示什么类型都可以  &lt;? extends A&gt; 表示A及其子类   &lt;? super A&gt; A及其父类 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandFather</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrandFather</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">add01</span><span class="hljs-params">(List&lt;?&gt; c)</span>&#123; <br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">add02</span><span class="hljs-params">(List&lt;? extends GrandFather&gt; c)</span>&#123;<br><br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">add03</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Father&gt; c)</span>&#123;<br><br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Object&gt; object=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;GrandFather&gt; grandFather=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Father&gt; father=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Son&gt; son=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        Util.add01(object); <span class="hljs-comment">//每一个都可以添加</span><br>        Util.add02(father); <span class="hljs-comment">//可以添加GrandFather的子类</span><br>        Util.add03(son);   <span class="hljs-comment">//不可以，因为son不是Father的父类</span><br>        Util.add03(grandFather);   <span class="hljs-comment">//可以添加</span><br>    &#125;<br><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="Io流："><a href="#Io流：" class="headerlink" title="Io流："></a>Io流：</h2><h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h3><p>文件流：</p><ul><li>输入和输出是以计算机内存视角来看的。从计算机内存写数据到文件（硬盘），叫输出流</li><li>从文件读数据到内存，叫输入流。就是输入进来的意思。流只是个名字（emo的名字）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//这里创建的文件，它的上级目录必须存在才能创建。并且创的是文件不是目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;e:\\file.txt&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            file.createNewFile();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    <br>      <span class="hljs-comment">//常用方法</span><br>        System.out.println(<span class="hljs-string">&quot;文件名字=&quot;</span>+file.getName());<br>        System.out.println(<span class="hljs-string">&quot;文件绝对路径=&quot;</span>+file.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;文件长度（字节数）=&quot;</span>+file.length());<br>        System.out.println(<span class="hljs-string">&quot;文件是否存在=&quot;</span>+file.exists());<br>        System.out.println(<span class="hljs-string">&quot;文件是不是个目录=&quot;</span>+file.isDirectory());<br>        System.out.println(<span class="hljs-string">&quot;文件是不是个文件=&quot;</span>+file.isFile());<br>     System.out.println(<span class="hljs-string">&quot;文件是否删除成功=&quot;</span>+file.delete());  <span class="hljs-comment">//只能删除空目录或者单个文件</span><br>    <br>    <span class="hljs-comment">//目录操作</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;e:\\file\\file02\\file03&quot;</span>);<br>        <span class="hljs-keyword">if</span> (file.exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;目录已经存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!file.mkdirs()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;创建失败&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>按照操作数据的单位不同，分为字节流（8bit）,字符流。从效率上来说，字符流一次读取的数据更多。但是在对于二进制文件，比如声音视频这种，字节流可以保证无损操作。而字符流用来读取文本文件时则更为适合</p><table><thead><tr><th align="center">抽象基类</th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center">输入流</td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center">输出流</td><td align="center">OutputSteram</td><td align="center">Writer</td></tr></tbody></table><p>其余的所有的子类都是以这个四个基类为结尾名字的类。</p><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        String path=<span class="hljs-string">&quot;e:\\file.txt&quot;</span>;<br>        <span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-type">int</span> readLen=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(path);<br>            <span class="hljs-keyword">while</span> (( readLen = fileInputStream.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//原理是：每一次输入流都会读8个字节，存放到bytes数组  </span><br>                System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes,<span class="hljs-number">0</span>,readLen));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileInputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//输出流</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <br>        String path=<span class="hljs-string">&quot;e:\\file.txt&quot;</span>;<br>        String text=<span class="hljs-string">&quot;hello word&quot;</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">            *  如果文件不存在，会自己创建。但是上级目录必须存在。如果不指定为true，会覆盖原数据。</span><br><span class="hljs-comment">            *  outputStream =new FileOutputStream(path,true); </span><br><span class="hljs-comment">            *  true就是追加</span><br><span class="hljs-comment">            */</span><br>            outputStream =<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(path);<br>            outputStream.write(text.getBytes());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                outputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>FileWriter和InputStream用法没有什么太大区别！但是FileWriter最后一定要调用close或者flush，不然内容还在内存。</p></blockquote><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p><img src="/blogImg/BufferedWriter.png" alt="BufferedWriter"></p><p><img src="/blogImg/BufferedWriter-02.png" alt="BufferedWriter-02"></p><ul><li>从BufferedWriter的构造器中我们可以发现传入的参数可以是一个Writer，那么就意味着Writer的所有子类都可以作为参数传递。这样BufferedWriter就可以通过传入的不同的Writer子类来实现各种不同的处理功能<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="图片来源和内容参考：韩顺平 零基础30天学会Java-哔哩哔哩 https://b23.tv/iluN6Xg">[1]</span></a></sup>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符缓冲处理流 字节缓冲处理流也是大同小异</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        String path=<span class="hljs-string">&quot;e:\\test.txt&quot;</span>;<br>        String path2=<span class="hljs-string">&quot;e:\\test2.txt&quot;</span>;<br>        BufferedReader reader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br>     BufferedWriter writer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path2,<span class="hljs-literal">true</span>));<br>        String line;<br>        <span class="hljs-comment">//按行读取，当返回为空时读完</span><br>        <span class="hljs-keyword">while</span> (( line= reader.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>            writer.write(line);<br>            System.out.println(line);<br>        &#125;<br>        writer.close();<br>        reader.close();<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>目的：保存数据的时候把数据的类型和值一起保存。这个过程就叫序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">//序列化后保存的文件形式并不是文本格式。而是一种特定的格式。所以这里是什么格式并不影响</span><br>        String path=<span class="hljs-string">&quot;e:\\data.dat&quot;</span>;<br>       <span class="hljs-comment">//提供序列化功能</span><br>        ObjectOutputStream objOut=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(path));<br>        objOut.writeInt(<span class="hljs-number">100</span>);<br>        objOut.writeBoolean(<span class="hljs-literal">true</span>);<br>        objOut.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>,<span class="hljs-number">2</span>));<br><br>       <span class="hljs-comment">//反序列化功能</span><br>        ObjectInputStream objInput=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(path));<br>        <span class="hljs-comment">//反序列化的顺序一定要和序列化的顺序一致</span><br>        System.out.println(objInput.readInt());<br>        System.out.println(objInput.readBoolean());<br>        System.out.println(objInput.readObject());<br><br>        objInput.close();<br>        objOut.close();<br>    &#125;<br><br><span class="hljs-comment">//这个Dog应该是一个是public类，这样反序列化时候才能找到。反正就是得让反序列化的这个方法，能够找到Dog的位置。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>作用：加一个版本号可以在修改原来的类的时候，让jvm知道这是同一个类，而不是新的类。这样对以前类进行反序列化时候就不会报错了。</p><p><strong>eg:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在Dog类没有序列号，我们在序列化保存后，手动添加一个属性 private int count;这时候进行反序列化就会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">报错信息：<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.io.InvalidClassException: com.code.api.Dog; local <span class="hljs-keyword">class</span> <span class="hljs-title class_">incompatible</span>: stream <span class="hljs-type">classdesc</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">808592382565188925</span>, local <span class="hljs-keyword">class</span> <span class="hljs-title class_">serialVersionUID</span> = -<span class="hljs-number">5347002648387494214</span><br></code></pre></td></tr></table></figure><p>然后现在我们在注释掉count属性，在Dog类中加入一个UID(值随意)，然后序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> serialVersionUID=<span class="hljs-number">1L</span>;<br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化成功后，我们重新新增count属性，再反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> serialVersionUID=<span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功：(记得加上toString方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">C:\Users\Administrator\.jdks\corretto-<span class="hljs-number">1.8</span><span class="hljs-number">.0_322</span>\bin\...<br><span class="hljs-number">100</span><br><span class="hljs-literal">true</span><br>Dog&#123;name=<span class="hljs-string">&#x27;旺财&#x27;</span>, age=<span class="hljs-number">2</span>&#125;<br><br>Process finished with exit code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1.序列化对象时，默认将里面的所以属性都序列化，除了static或transient修饰的成员外！</p><p>2.序列化对象时，要求里面的属性也需要实现序列化接口。（基本数据类型的包装类型已经默认实现了）</p><p>3.序列化具有继承性，也就是说父类实现了序列化，那么它的子类也默认实现</p></blockquote><h3 id="转换（包装）流解决乱码问题"><a href="#转换（包装）流解决乱码问题" class="headerlink" title="转换（包装）流解决乱码问题"></a>转换（包装）流解决乱码问题</h3><p>前面我们读取文件时候，如果是文本文件，我们一般用字符流，因为用字节流读取含有中文的文件时候，会有乱码问题。而且不同的编码会有一定的乱码问题</p><p>转换流就可以把字节流转换成字符流，并且字节流可以指定编码格式</p><p><img src="/blogImg/WrapperStream.png" alt="WrapperStream"></p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">properties内容：<br><br>name=code<br>pwd=<span class="hljs-number">123456</span><br>adress=localhost<br><span class="hljs-comment">//传统的解析，但是这种方式有很多问题。比如修改配置文件，或者只读取里面的某个kv，显得很繁琐</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    String path=<span class="hljs-string">&quot;src/jdbc.properties&quot;</span>;<br>    BufferedReader reader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br>    String line;<br>    <span class="hljs-keyword">while</span> ((line=reader.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>        String[] strings = line.split(<span class="hljs-string">&quot;=&quot;</span>);<br>        System.out.println(strings[<span class="hljs-number">0</span>]+<span class="hljs-string">&quot;:&quot;</span>+strings[<span class="hljs-number">1</span>]);<br>    &#125;<br>    reader.close();<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Peoperties类"><a href="#Peoperties类" class="headerlink" title="Peoperties类"></a>Peoperties类</h4><blockquote><p>Peoperties配置文件中的键值对只能用=连接，=两边不能有空格</p><p>1.加入k有空格怎么办呢？(它会解析成=)</p><p>2，在对properties写入数据时，如果格式有问题，它会自己做出一些修改。（具体code）</p></blockquote><p>常用方法：</p><ol><li>load：加载配置文件的键值对到Peoperties对象</li><li>list：将数据显示到指定设备</li><li>getProPerty(key):根据键获取值</li><li>setProperty(k,v):设置键值对到peoperties对象.不存在即创建，存在即修改</li><li>store：将Peoperties的键值对存储到配置文件，在ieda中，保存信息到配置文件，如果含有中文，会存储Unicode编码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       String path=<span class="hljs-string">&quot;src/jdbc.properties&quot;</span>;<br>       Properties properties=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>       properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br>       <span class="hljs-comment">//输出文件</span><br>       properties.list(System.out);<br>       <span class="hljs-comment">//根据键获取值</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;name&quot;</span>);<br>       <span class="hljs-comment">//现在只是创建键值对</span><br>       properties.setProperty(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Helen&quot;</span>);<br>       properties.setProperty(<span class="hljs-string">&quot;hobbit&quot;</span>,<span class="hljs-string">&quot;ping-pang&quot;</span>);<br>       <span class="hljs-comment">//然后写入！！！</span><br>       properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path),<span class="hljs-string">&quot;文件的注释&quot;</span>);<br><br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="properties大致原理"><a href="#properties大致原理" class="headerlink" title="properties大致原理"></a>properties大致原理</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#Sun Nov 13 09:16:59 CST 2022</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">Helen</span><br><span class="hljs-attr">hobbit</span>=<span class="hljs-string">ping-pang</span><br></code></pre></td></tr></table></figure><p>从上面来看，我们可以知道properties可以得到配置文件中的键值对，也能把想要的键值对写入到配置文件。那么这个过程是怎么做到的呢？浅浅的说一下</p><p><img src="/blogImg/properties01.png"></p><p>首先调用一个输入流，把properties的字符读入到一个字符数组里面（容量大小是8192）.前面的一串字符是默认的properties的注释。从name开始就是自己设置的键值对。可以看出在保存字符的时候，如果读取到了换行，它会自己在字符数组中插入换行和空格的转义字符。这样就方便接下来的分割了。</p><p><img src="/blogImg/properties02.png"></p><p><img src="/blogImg/properties03.png"></p><p>然后就开始分析这个字符数组，以每一个换行结束。KeyLen这些表示的是要截取多少个长度的字符。比如上面的4，就是读四个字符(name)，然后转成一个String，这个String就是k.value也是同样的道理，从第几个字符开始，然后长度为多少。现在得到了k=name,v=Helen后，就把这个键值对put(<strong>properties继承了HashTable</strong>)。这样<strong>第一个键值对</strong>就解析完毕了。（它的配置文件的标题并不会放入table）第二个就从上一个结束的地方开始，继续解析。直到全部解析结束</p><p>那么对应的list方法，就是遍历这个table，输出数据。set方法就是直接调用put方法。然后把数据存进hashTable后，才写入到配置文件。这也就解释了为什么properties.setProperty(“hobbit”,”ping-pang”)后。还要properties.store(new FileWriter(path),null);第二步才是用输出流写入数据</p><blockquote><p>IO类比较多，名字也很容易混淆。但是只要记住四个基本，字节流和字符流就行。基本的方法都是大同小异，具体需要时候再去查阅文档也是可以的！</p><p>properties的源码涉及较多的字符操作，如果想要自己debug，建议把kv字符串设置简短一点。比如id=code ,更方便调试</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>图片来源和内容参考：韩顺平 零基础30天学会Java-哔哩哔哩 <a href="https://b23.tv/iluN6Xg">https://b23.tv/iluN6Xg</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>泛型</tag>
      
      <tag>IO</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java常见集合扩容原理</title>
    <link href="/java%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86/"/>
    <url>/java%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>选取了[ArrayList,Vector,HashMap/HashSet]进行简单说明</p></blockquote><p><img src="/blogImg/Collection.png" alt="CollectionDiagrams"></p><h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList:"></a>1.ArrayList:</h3><h4 id="1-1-ArrayList类的基本属性"><a href="#1-1-ArrayList类的基本属性" class="headerlink" title="1.1 ArrayList类的基本属性"></a>1.1 ArrayList类的基本属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&#123;<br>    <span class="hljs-comment">//共享空数组实例用于默认大小的空实例 用于无参构造时候给elementData实例化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br>    <span class="hljs-comment">//共享空数组实例用于默认大小的空实例 用于指定初始容量构造时给elementData实例化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br>    <br>    <span class="hljs-comment">//数组的默认容量，第一次扩容时会使用到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//这个是真正用来存放list数据的数组</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br>    <br>    <span class="hljs-comment">//存放ArrayList的大小</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">//记录list被修改的次数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">modCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>&#125; <br></code></pre></td></tr></table></figure><h4 id="1-2-无参构造下的扩容："><a href="#1-2-无参构造下的扩容：" class="headerlink" title="1.2 无参构造下的扩容："></a>1.2 无参构造下的扩容：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//这里只是给Data赋了一个空值，此时elementData的容量为0</span><br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>   <span class="hljs-comment">//这里开始添加元素，该方法是判断数组容量是否足够存放元素。因为每次元素都是+1；如果是第一个元素，此时数组容量为0，而需要的最小容量是1.</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>     <span class="hljs-comment">//承接上面方法，此时的minCapacity是1，elementData为0.调用calculateCapacity方法</span><br>        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">//因为是调用无参构造，且是第一次添加元素。此时if成立。返回的就是DEFAULT_CAPACITY，也就是10。如果</span><br>    <span class="hljs-comment">//不是调用了无参构造，那么就返回需要的最小容量minCapacity</span><br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minCapacity;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// 此时判断需要的最小容量是否大于数组的长度。在无参情况下，length=10.假如数组元素超过了10,才调用grow方法进行扩容</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            grow(minCapacity);<br>    &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>       <span class="hljs-comment">//新的数组容量为原来的+0.5（右移一位表示缩小一半）=1.5</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>      <br>       <span class="hljs-comment">//复制原数组。扩容完成</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-3-指定初始容量下的扩容"><a href="#1-3-指定初始容量下的扩容" class="headerlink" title="1.3 指定初始容量下的扩容"></a>1.3 指定初始容量下的扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//这里就直接指定了初始容量大小</span><br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//假如初始容量为0，发现elementData并不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA。因此即使初始容量为0，第一次扩容</span><br>        <span class="hljs-comment">//也并不会变成初始容量10 了。</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">//指定了initialCapacity后，if就不成立。此时就直接返回需要的最小容量。然后判断容量是否足够，不够就调用grow扩容</span><br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minCapacity;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p>在无参构造情况下，ArrayList第一次扩容后elementData数组容量为10，此后每次扩容为原来的1.5倍</p></li><li><p>在指定了初始容量情况下（初始容量不为0），初始容量就是指定的大小，以后每次扩容均为原来的1.5倍</p></li><li><p>如果初始容量为0，第一次扩容后数组的大小为1。请看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> ArrayList&lt;Integer&gt; list1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> ArrayList&lt;Integer&gt; list2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">0</span>);<br><br>list1初始容量为<span class="hljs-number">0</span>，第一次扩容就为<span class="hljs-number">10</span>；<br>list2初始容量也为<span class="hljs-number">0</span>，但是第一次添加数据后容量是<span class="hljs-number">1.</span>请仔细分析 grow（）方法中的<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/blogImg/ArrayList01.png" alt="ArrayList-debug"></p><hr><h3 id="2-Vector"><a href="#2-Vector" class="headerlink" title="2.Vector"></a>2.Vector</h3><h4 id="2-1-Vevtor类的基本属性"><a href="#2-1-Vevtor类的基本属性" class="headerlink" title="2.1 Vevtor类的基本属性"></a>2.1 Vevtor类的基本属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Vector&#123;<br>    <span class="hljs-comment">//保存数据的数组</span><br>    <span class="hljs-keyword">protected</span> Object[] elementData<br>        <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> elementCount;<br>    <span class="hljs-comment">//这个和扩容有关，下面会用到</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> capacityIncrement;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-扩容原理"><a href="#2-2-扩容原理" class="headerlink" title="2.2 扩容原理"></a>2.2 扩容原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-number">10</span>);<br>    &#125;<br><br><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>     <span class="hljs-comment">//直接指定了初始容量为10</span><br>        <span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> capacityIncrement)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>      <span class="hljs-comment">//capacityIncrement记住这个，此时值为0</span><br>        <span class="hljs-built_in">this</span>.capacityIncrement = capacityIncrement;<br>    &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>      <span class="hljs-comment">//这个和ArrayList中的一样 我们主要继续查看ensureCapacityHelper()方法</span><br>        modCount++;<br>        ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>        elementData[elementCount++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// 同样的判断容量是否够存放数据</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            grow(minCapacity);<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">//此时观察看，当capacityIncrement不大于0时，扩容就为原来的两倍。如果capacityIncrement&gt;0,容量则为原来的+capacityIncrement</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                         capacityIncrement : oldCapacity);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br><span class="hljs-comment">//下面这个Vector的构造器中就可以显示的指定capacityIncrement的值是否&gt;0!</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> capacityIncrement)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        <span class="hljs-built_in">this</span>.capacityIncrement = capacityIncrement;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul><li>直接调用无参构造或者不指定capacityIncrement的值时候，第一次扩容为10，第二次为原来的两倍</li><li>capacityIncrement值&gt;0时，扩容大小为原来的容量+capacityIncrement</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>     Vector&lt;Integer&gt; vector1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>     <span class="hljs-comment">//主要这里不能设置成1,1.因为1的2倍是2,2+2也是2.这样就无法证明capacityIncrement带来的影响了</span><br>      Vector&lt;Integer&gt; vector2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>      Vector&lt;Integer&gt; vector3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>      vector1.add(<span class="hljs-number">1</span>);<br><br>      vector2.add(<span class="hljs-number">1</span>);<br>      vector2.add(<span class="hljs-number">2</span>);<br><br>      vector3.add(<span class="hljs-number">1</span>);<br>      vector3.add(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//根据分析，vector1容量应该为10，vector2为1+2=3，vector3应为1的两倍2</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/blogImg/vector-01.png" alt="vector-01"></p><hr><blockquote><p>既是集合，那么集合的特征就是不重复无序。</p></blockquote><h3 id="3-HashSet-HashMap"><a href="#3-HashSet-HashMap" class="headerlink" title="3.HashSet/HashMap"></a>3.HashSet/HashMap</h3><h4 id="3-1-基本属性"><a href="#3-1-基本属性" class="headerlink" title="3.1 基本属性"></a>3.1 基本属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&#123;<br>    <span class="hljs-comment">//final类型的Object，充当map中的值。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">//节点数组，记住下面的所有table都是这个成员变量，是用来存放数据的。（因为有很多局部变量）</span><br>    <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br>    <span class="hljs-comment">//默认的容量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//加载因子</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">//阈值，即table长度达到这个值后就会扩容</span><br>    <span class="hljs-type">int</span> threshold;<br>    <span class="hljs-comment">//链表转红黑树的阈值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">//树化的最小条件</span><br>     <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br>    <br>    <span class="hljs-comment">//静态内部类Node的定义</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; next;<br><br>        Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-无参构造扩容原理"><a href="#3-2-无参构造扩容原理" class="headerlink" title="3.2 无参构造扩容原理"></a>3.2 无参构造扩容原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//直接就是new一个HashMap，所以HashSet是基于HashMap实现的</span><br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><span class="hljs-comment">//先根据key算出hash值，根据hash值，key，v插入数据。v就是PRESENT了</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal()方法:"></a>putVal()方法:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab;<br>    Node&lt;K,V&gt; p; <br>    <span class="hljs-type">int</span> n, i;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * (tab = table)，(n = tab.length) 这种意思是先给局部变量tab赋值。因为局部变量都是必须要初始化的，如果是:</span><br><span class="hljs-comment"> *  第一个元素的添加，此时第一个if成立。进入resize（）方法</span><br><span class="hljs-comment"> *第二次后，tab已经不等于空了，进入第二个if判断是否有hash冲突</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <br>   <span class="hljs-comment">//tab[i = (n - 1) &amp; hash]根据hash值计算这个key应该存放在哪个索引的node位置，将该node赋给p.如果p==null，</span><br>   <span class="hljs-comment">//说明该位置不存在数据，没有hash冲突。就新建一个node。然后将该node放入tal[i]的位置</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <br>    <span class="hljs-comment">//如果有hash冲突</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//比较当前索引位置的hash和key是否与要加入的key完全相等，即是否为同一个对象</span><br>        <span class="hljs-comment">//或者key的值是相等的，就不能添加了。</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;  <br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">//如果不是上面为false，就判断p是不是一颗红黑树。putTreeVal为红黑树插入。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">//不是红黑树，那么就是一个链表。</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">//此时e==null</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//在链表末尾插入newNode，先插入在判断</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">//如果发现已经有了8个节点，就开始树化。但是treeifyBin还有一个判断</span><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="hljs-comment">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="hljs-comment">        当tab数组的长度小于MIN_TREEIFY_CAPACITY（64）时，会先扩容。并不会树化。</span><br><span class="hljs-comment">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="hljs-comment">         resize();</span><br><span class="hljs-comment">     */</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//同样的依次比较链表上的每个node是否和要插入的node冲突，有冲突直接break。</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//发现有冲突，就不能添加了</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">//判断size是否大于了阈值。我们可以发现只要map添加了元素，size都会++</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">//留给它的子类实现的。是一个空方法。可能是为了方便扩展吧</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法:"></a>resize()方法:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *第一次添加oldTab==null，所以oldCap=0，oldThr等于默认值=0.</span><br><span class="hljs-comment">    */</span><br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//假如原来的数组容量不为空   记住：：Thr结尾的就表示阈值，Cap结尾的表示容量 new表示新的...,old表示原来的...</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double 新的阈值和Cap都左移一位，变成两倍</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">*第一次添加元素，直接到了这里，新的容量newCap就为16（1&lt;&lt;4）. </span><br><span class="hljs-comment">*新的阈值等于DEFAULT_LOAD_FACTOR（0.75）*16=12</span><br><span class="hljs-comment">   */</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;  <span class="hljs-comment">//赋值，阈值等于12</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <span class="hljs-comment">//此时发现new了一个数组容量为newCap=16的数组，然后赋给table</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <br>    <span class="hljs-comment">//这个方法就是将原来的tab内容挂载到新的tab上去</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//将原来的数组内容置空</span><br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//该索引位置只有一个元素</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">//假如该索引位置恰好是个链表</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *第一次元素添加，扩容后直接返回新的数组</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-指定initialCapacity的有参构造"><a href="#3-3-指定initialCapacity的有参构造" class="headerlink" title="3.3 指定initialCapacity的有参构造"></a>3.3 指定initialCapacity的有参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>      <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<span class="hljs-comment">//已经默认指定了，就是0.75f</span><br>  &#125;<br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>      <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                             initialCapacity);<br>      <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>          initialCapacity = MAXIMUM_CAPACITY;<br>      <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                             loadFactor);<br>     <span class="hljs-comment">//走到这里我们可以发现，在创建一个HashMap时候，这个table都是空的。这是只是计算出了阈值</span><br>      <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>      <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);   <br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="tableSizeFor-方法-1"><a href="#tableSizeFor-方法-1" class="headerlink" title="tableSizeFor()方法[1]"></a>tableSizeFor()方法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[HashMap之tableSizeFor方法图解 - 希夷小道 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiyixiaodao/p/14483876.html)">[1]</span></a></sup></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//hashmap保证容量必须是2的整数幂，为了保证这一点，专门给出了一个巧妙而高效的方法tableSizeFor。说白了初始容量会是一个</span><br><span class="hljs-comment">//不小于它的最接近的2的整数幂m。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>       Node&lt;K,V&gt;[] oldTab = table;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>       <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>               threshold = Integer.MAX_VALUE;<br>               <span class="hljs-keyword">return</span> oldTab;<br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>               newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <br>       &#125;<br>    <span class="hljs-comment">//此时这个条件成立。老的阈值是&gt;0的。所以新的容量就等于原来的阈值  Thr就表示阈值，Cap表示容量</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <br>           newCap = oldThr;<br>       <span class="hljs-keyword">else</span> &#123;               <br>           newCap = DEFAULT_INITIAL_CAPACITY;<br>           newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                     (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>       &#125;<br>       threshold = newThr;<br>       <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>       table = newTab;<br></code></pre></td></tr></table></figure><blockquote><p>ps:    假如HashSet<String> hashSet=new HashSet&lt;&gt;(0);那么第一次扩容后hashSet容量是多少？   </p></blockquote><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p><strong>无参构造情况下</strong>：</p><ul><li>加载因子默认为0.75.</li><li>第一次扩容，数组容量为16.以后每次数组容量变为原来的2倍</li><li>阈值是容量*加载因子。即table中的size达到阈值时就会扩容</li><li>在table表中，不管是在链表上还是红黑树上添加元素，都会占用一个table容量。</li><li>树化的条件是table数组长度&gt;64且链表上的元素超过了8</li></ul><p><strong>指定了initialCapacity的有参构造</strong>：</p><ul><li>第一次扩容量为最接近initialCapacity的2的整数幂。</li><li>initialCapacity=0时，第一次扩容后容量为2。因为会调用两次resize()方法！！</li></ul><h6 id="两个小demo-2-："><a href="#两个小demo-2-：" class="headerlink" title="两个小demo[2]："></a>两个小demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="韩顺平 零基础30天学会Java-哔哩哔哩 https://b23.tv/OJFIOY2">[2]</span></a></sup>：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>如果想要debug查看map元素添加时候触发链表和树化，那么就要tal上的元素满足hash相同，但是equals方法结果不同。所以我们重写hashCode方法。但是不重写equals方法。<span class="hljs-comment">//该方法来自于韩顺平老师的bilibili课程，java基础！</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMap</span>&#123;<br>    <span class="hljs-keyword">private</span> String value;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestMap</span><span class="hljs-params">(String value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value=value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-number">2.</span>在resize方法中，有一段tab表拷贝的方法。里面涉及到了如何将链表挂载到新的tab表上去。下面这段代码，刚好有个索引处挂载了<br>    一条链条，且该链表只有两个元素。非常适合用于debug。（这是自己debug时候不经意写的代码，出现了个hash冲突）<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>       HashSet&lt;String&gt; hashSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;<br>            hashSet.add(i+<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        hashSet.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;goof&quot;</span>);<span class="hljs-comment">//在这debug，就能进入到resize中后面那一串代码</span><br>        hashSet.add(<span class="hljs-string">&quot;qqq&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/xiyixiaodao/p/14483876.html">HashMap之tableSizeFor方法图解 - 希夷小道 - 博客园 (cnblogs.com)</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>韩顺平 零基础30天学会Java-哔哩哔哩 <a href="https://b23.tv/OJFIOY2">https://b23.tv/OJFIOY2</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>源码</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
